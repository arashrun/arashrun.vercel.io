<!DOCTYPE html> <html><head>
		<title>os</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="source - os">
		<meta property="og:title" content="os">
		<meta property="og:description" content="source - os">
		<meta property="og:type" content="website">
		<meta property="og:url" content="_posts/os.html">
		<meta property="og:image" content="lib\media\段表.png">
		<meta property="og:site_name" content="source">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light ctp-rosepine-light ctp-mocha-old ctp-accent-light-rosewater ctp-accent-rosewater anuppuccin-accent-toggle anp-h1-red anp-h2-peach anp-h3-green anp-h4-teal anp-h5-lavender anp-h6-mauve anp-bold-red anp-italic-green anp-highlight-yellow"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading" id="os"><p>os</p></h1><div><hr></div><div><p>title: OS原理<br>
date: 2022-04-07 22:31:08<br>
categories:</p></div><div><ul>
<li data-line="0">cs基础<br>
tags:</li>
</ul></div><div><hr></div><div class="heading-wrapper"><h3 data-heading="内存管理" class="heading" id="内存管理"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>内存管理</h3><div class="heading-children"><div><blockquote>
<p>编译（源程序模块）---》链接（目标模块）---》装入(装入模块)</p>
<p>1.链接和装入的策略，分为3种。在磁盘上，在内存中，在cpu执行时。</p>
<p>2.一个程序的运行，需要经过几道程序的运行。（编译器---链接器---装入内存（装入器）---内存分配（内存管理器））</p>
<p>​	编译器：将程序员写的源程序编译为目标模块</p>
<p>​	链接器：多个目标模块拼接，<strong>通过一定的策略</strong>形成可装入模块</p>
<p>​	装入器：将可装入模块，<strong>通过一定的策略</strong>装入内存</p>
<p>​	内存管理器：配合装入器，<strong>通过一定的策略</strong>完成对程序运行所需内存的分配</p>
</blockquote></div><div class="heading-wrapper"><h4 data-heading="链接策略" class="heading" id="链接策略"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>链接策略</h4><div class="heading-children"><div><ol>
<li data-line="0">静态链接：在装入内存之前，将各个目标模块链接起来。形成可装入模块（linux中就是链接.a静态库）</li>
<li data-line="1">装入时动态链接：边装入边链接</li>
<li data-line="2">运行时动态链接：执行时需要的时候才链接目标模块</li>
</ol></div></div></div><div class="heading-wrapper"><h4 data-heading="装入策略（装入器loader）" class="heading" id="装入策略（装入器loader）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>装入策略（装入器loader）</h4><div class="heading-children"><div><ol>
<li data-line="0">绝对装入：程序的逻辑地址==进程的物理地址。缺点：编写的程序必须从指定位置开始，必须非常了解内存要求。常用于单道程序环境</li>
<li data-line="1">可重定位装入：当程序被装入程序（loader）装入内存后根据实际可用物理地址来变更程序中全文的地址。此时能够运行躲到程序缺点：程序装入之后，不可动态修改程序中的地址</li>
<li data-line="2">运行时动态装入：在指令被执行时，才动态修改地址。</li>
</ol></div></div></div><div class="heading-wrapper"><h4 data-heading="内存分配策略（内存管理器mm_manager）" class="heading" id="内存分配策略（内存管理器mm_manager）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>内存分配策略（内存管理器mm_manager）</h4><div class="heading-children"><div><p>操作系统对内存的分配，大体上可以分为两个思路。1.分割内存，不分割装入模块（连续分区分配）。2.分割内存，并且分割程序（分页，分段，段页）</p></div><div><p><strong>连续分区分配：</strong></p></div><div><p>​	顾名思义，也就是程序作为一个整体装入内存中。而根据对内存的分割策略来看，有3种方式。</p></div><div><ol>
<li data-line="0">单一连续分配（整个内存分为内核区，和用户区。用户区只有一道程序）</li>
<li data-line="1">静态分区分配（将用户区，划分固定大小的几个区域。开始可以存放多道程序，但可能有的程序很小，但是占据很大的区域，造成浪费）</li>
<li data-line="2">动态分区分配（根据程序的大小来确定内存分区的大小）</li>
<li data-line="3">动态重定位分区分配算法（在动态分区分配的基础上增加“紧凑”功能，减少内存的碎片，为了实现紧凑功能需要配合运行时动态装入的装入算法）</li>
</ol></div><div><p><strong>分页、分段、段页内存分配：</strong></p></div><div><p>​	这些分配方式，不仅分割内存，还分割装入模块（进程）。可以看作数据结构中的链表。整个进程离散地分散到内存不同位置。不像连续分配，将装入模块整体装入。</p></div><div><ul>
<li data-line="0">
<p>分页</p>
<p>将程序和内存空间分割成多个大小一样的片段（页面），操作系统的内存管理模块通过为程序建立页表，然后MTU地址转换单元通过查询进程的页表，来实现程序地址的动态重定位。</p>
<p>当访问进程的某一条指令（比如：load 1，2500）2500是程序的逻辑地址，MTU首先计算得出该逻辑地址对应的程序分页中的页号，和页内偏移。然后通过在页表中查询到程序分页中的页号对应的物理块号，得到物理块号之后和前边的页内偏移相加，从而完成程序的逻辑地址到物理地址的转换。</p>
</li>
<li data-line="6">
<p>分段</p>
<p>由于分页方法（固定大小的页面的缺点：不符合程序中指令和数据的排布，导致）的缺陷，提出一种分段内存分配的算法，将一个程序分割为不同段：代码段，数据段，堆段，栈段，bss段，作为一个查询单位。而将内存分割为与程序相同的段。这样只要通过段表查询到段基址，就能保证能够每一个段在内存中是连续分配的。</p>
</li>
</ul></div><div><p></p><div src="lib/media/段表.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/段表.png"></div><p></p></div><div><ul>
<li data-line="0">
<p>段页式</p>
<p>分页的好处是能够节省内存，分段的好处是程序友好，方便编程。为了结合两方面优势，将每一个程序段通过分页处理，然后通过段号找到页号，通过页号找到物理地址。</p>
</li>
</ul></div><div><blockquote>
<p><strong>内存模型到底是什么：</strong>现在的编译器会将我们的程序进行分段处理，<strong>c语言，c++中的内存模型，其实就是编译器所规定的一种逻辑上的程序组织方式，在内存中每一个段可能连续的一块（段式）来存储，也可能一个程序段分布在不同的物理内存（段页式）来存储，</strong>然后在执行指令，进行地址转换时，操作系统根据实际内存分配方式，完成逻辑地址（每一个段的逻辑地址都是从0号开始的）到物理地址的转换，然后cpu访问物理地址来执行我们的程序。</p>
</blockquote></div><div><hr></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="unix系统标准&amp;unix实现" class="heading" id="unix系统标准&amp;unix实现"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>unix系统标准&amp;unix实现</h3><div class="heading-children"><div><p><strong>unix标准</strong></p></div><div><ul>
<li data-line="0">iso c：该标准定义了c语言语法语义和c语言标准库，因为是所以unix都提供了c标准中的库函数，因此默认也就成了一种标准</li>
<li data-line="1">ieee posix：该标准的目的是提高应用程序在各种unix系统环境之间的可移植性</li>
<li data-line="2">SUS=single unix specification（单一unix规范）：是posix的超集，在posix的基础上还规定了一些操作系统接口，扩展了posix的功能</li>
</ul></div><div><p><strong>unix实现</strong></p></div><div><p>SVR4(system v release 4)：System V 是 AT&amp;T 的第一个商业UNIX版本（UNIX System III）的加强。传统上，System V 被看作是两种UNIX"风味"之一（另一个是 BSD）。然而，随着一些并不基于这两者代码的<a data-tooltip-position="top" aria-label="https://baike.baidu.com/item/UNIX/219943" rel="noopener" class="external-link" href="https://baike.baidu.com/item/UNIX/219943" target="_blank">UNIX</a>实现的出现，例如 Linux 和 QNX， 这一归纳不再准确，但不论如何，像POSIX这样的标准化努力一直在试图减少各种实现之间的不同。流行的SysV 衍生版本包括 Dell SVR4 和 Bull SVR4。当今广泛使用的 System V 版本是 SCO OpenServer，基于 System V Release 3，以及SUN Solaris 和 SCO UnixWare，都基于 System V Release 4。</p></div><div><p>BSD:</p></div><div><hr></div></div></div><div class="heading-wrapper"><h3 data-heading="磁盘到文件系统" class="heading" id="磁盘到文件系统"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>磁盘到文件系统</h3><div class="heading-children"><div><blockquote>
<p>文件系统：是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。</p>
</blockquote></div><div><p><strong>数据在硬盘上的存储和组织方式</strong>：</p></div><div><p></p><div src="lib/media/连续块存储.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/连续块存储.png"></div><p></p></div><div><p><strong>连续块存储：</strong>这是一种最简单的实现方式，管理便捷。但最大的问题是空洞问题，即使物理磁盘还有空余容量，也不能再写入文件了。常见于CD-ROM等预先明确数据大小的存储器</p></div><div><p></p><div src="lib/media/链表式存储.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/链表式存储.png"></div><p></p></div><div><p><strong>链表式存储：</strong>好处是不存在存储空洞且只需要记住第一个block的位置即可，缺点很明显：就是会造成大量的随机IO，而且读取完一个block才知道下一个block的位置，效率过低。为了改进这种效率问题，FAT诞生</p></div><div><p></p><div src="lib/media/fat文件系统.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/fat文件系统.png"></div><p></p></div><div><p><strong>FAT：</strong>链表式存储中，next指针是存储在每个block中的，而FAT把这些指针统一写在一个array中，这样获取一个文件的所有block位置就变得简单很多，效率也更高。但FAT也有一定的限制，比如FAT16只有65536个位置，FAT32虽然有更多的指针位，但是FAT表本身也占用了更大的内存。且FAT在读取某一文件中部时效率低，因为需要链表遍历。此外，FAT格式的文件系统不利于扩展文件的metadata。</p></div><div><p></p><div src="lib/media/linux的inode原理.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/linux的inode原理.png"></div><p></p></div><div><p><strong>I-Node：</strong>Linux 文件系统的思想是把所有与数据本身无关的data（如类型，大小，owner，创建修改时间等）都存进一个特殊的block中（inode），然后通过这个block可以找到与数据相关的所有block</p></div><div><p></p><div src="lib/media/inode实现原理.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/inode实现原理.png"></div><p></p></div><div><p>可以看到，每个inode都有12个直接block指针，假设每个block是4k，那么有48k的地址可以通过一次寻址直接找到，这对小文件的寻址速度有非常大的帮助，而文件系统中，绝大多数文件都是小文件，这样也就直接提高了文件系统的性能。如果有大文件，可以通过二次甚至三次间接寻址的方式来获取block地址，目的是能节省inode占用的空间，把更多的空间留给数据。</p></div><div><p></p><div src="lib/media/inode寻址过程.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/inode寻址过程.png"></div><p></p></div><div><p>这里有一个比较清晰地例子表明，文件系统是如何将path转变为真正的block地址的。简而言之，inode树组成了目录树，通过树形查找获取磁盘信息。</p></div><div><ul>
<li data-line="0">【原文出处】<a rel="noopener" class="external-link" href="https://www.jianshu.com/p/a5d783643fc2" target="_blank">https://www.jianshu.com/p/a5d783643fc2</a></li>
<li data-line="1">【linux内核对IO体系的实现】<a rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/96391501" target="_blank">https://zhuanlan.zhihu.com/p/96391501</a></li>
<li data-line="2"></li>
</ul></div><div><hr></div></div></div><div class="heading-wrapper"><h3 data-heading="系统调用" class="heading" id="系统调用"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>系统调用</h3><div class="heading-children"><div><blockquote>
<p>系统调用是操作系统提供给用户态程序使用操作系统功能的接口，是在有操作系统的情况下访问硬件资源或内核的----唯一入口---。</p>
</blockquote></div><div><p>实现方式：<br>
《linux下用户态程序使用系统调用》<br>
1.高级语言如c/c++，通过使用封装好的c库（lib）函数，通常一个标准函数会使用一个或多个系统调用来实现<br>
例如：printf --》 write系统调用<br>
scanf	--》	read系统调用	<br>
2.汇编语言，则是直接跟内核通信。内核中系统调用是通过中断机制来实现的，操作系统通过自定义内存中的中断向量表，将中断向量指向内核中的中断处理例程（程序）。而系统调用的中断在汇编中是用（int 80h）指令来实现的，<br>
参考<br>
<a rel="noopener" class="external-link" href="http://blog.sina.com.cn/s/blog_51e9c0ab010099ow.html" target="_blank">http://blog.sina.com.cn/s/blog_51e9c0ab010099ow.html</a>	系统调用</p></div><div class="heading-wrapper"><h4 data-heading="文件I/O" class="heading" id="文件I/O"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>文件I/O</h4><div class="heading-children"><div><p>​	/*<br>
​		linux中文件的内涵很多，<br>
​		内核将加载到内存中的文件称为文件描述符，文件有很多种：普通文件，pipe（管道），fifo，终端。。。<br>
​		进程通过使用文件描述符来使用内存中的文件对象。通常加载文件使用open系统调用来完成。<br>
​		使用文件描述符的I/O函数是无缓冲，以字节为单位进行读写的。而标准io设置了缓冲区，读写单位可以是行（以换行符结尾）<br>
​		全文（通过malloc分配文件大小的内存）。</p></div><div><p>​		</p></div><div><p>​		文件描述符fd---&gt;文件表项---&gt;i节点表项</p></div><div><p>​	<em>/<br>
​	int open(const char</em> filename, int flags, ...)<br>
​											filename:要打开的文件名<br>
​											flags:	设置文件的操作方式（只读，只写，读写）</p></div></div></div><div class="heading-wrapper"><h4 data-heading="进程" class="heading" id="进程"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>进程</h4><div class="heading-children"><div><p><strong>操作进程环境表</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">//每一个进程都会在栈段的上部存放一些系统的相关信息（环境表）</span>

<span class="token comment">//获取name对应的value</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token comment">//cg=value</span>
<span class="token comment">//将name=value字符串放入环境表</span>
<span class="token keyword">int</span> <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
<span class="token comment">//将name设置为value.</span>
<span class="token keyword">int</span> <span class="token function">setenv</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span> rewrite<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>进程创建与退出</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
	<span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg:father=pid,son=0</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
		<span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行清理工作（执行终止处理程序，关闭标准IO），然后陷入内核</span>
		<span class="token keyword">void</span> <span class="token function">_Exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//status：进程终止状态</span>
		<span class="token comment">//进程注册终止处理函数</span>
		<span class="token keyword">int</span> <span class="token function">atexit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
		<span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>执行新程序</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token comment">//区别：1.前四个使用路径名，后两个使用文件名 2.参数arg传递方式l（代表list=独立参数），v（代表vector=指针数组）</span>
<span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>获得进程终止状态</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>statloc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>statloc<span class="token punctuation">,</span> <span class="token keyword">int</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">waitid</span><span class="token punctuation">(</span><span class="token class-name">idtype_t</span> idtype<span class="token punctuation">,</span> <span class="token class-name">id_t</span> id<span class="token punctuation">,</span> siginfo <span class="token operator">*</span>infop<span class="token punctuation">,</span> <span class="token keyword">int</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token class-name">pid_t</span> <span class="token function">wait3</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>statloc<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rusage</span> <span class="token operator">*</span>rusage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">pid_t</span> <span class="token function">wait4</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>statloc<span class="token punctuation">,</span> <span class="token keyword">int</span> opt<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rusage</span> <span class="token operator">*</span>ruage<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="进程间通信（IPC）" class="heading" id="进程间通信（IPC）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>进程间通信（IPC）</h4><div class="heading-children"><div><blockquote>
<p>pipe（管道）</p>
<p>fifo（命名管道）</p>
<p>消息队列</p>
<p>信号量</p>
<p>共享存储</p>
<p>套接字</p>
</blockquote></div><div><p>XSI ipc(标识符用于进程中，键key可用于不同进程中标识同一个内核ipc结构)</p></div><div><p><strong>消息队列</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=队列标识符</span>
<span class="token comment">//cmd对队列要执行的操作（IPC_STAT,IPC_SET,IPC_RMID)分别取buf，设置buf，移除buf</span>
<span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msgid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msgid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token comment">//ptr代表消息，nbytes消息大小，flag可以设置为非阻塞发送消息到队列</span>
<span class="token keyword">int</span> <span class="token function">msgsend</span><span class="token punctuation">(</span><span class="token keyword">int</span> msgid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token comment">//type代表取消息的方式，flag可以设置为MSG_NOERROR</span>
<span class="token keyword">int</span> <span class="token function">msgrecv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msgid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span> <span class="token keyword">long</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>信号量</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/sem.h&gt;</span></span>
<span class="token comment">//linux上是信号量集合，因此需要一个参数nsems指定集合大小</span>
<span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=信号量标识符</span>
<span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> semoparray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> nops<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>共享存储</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=共享存储id</span>
<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=共享存储的地址</span>
<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>shm共享内存和内存映射mmap</strong></p></div><div><blockquote>
<p><a data-tooltip-position="top" aria-label="https://blog.csdn.net/ababab12345/article/details/102931841" rel="noopener" class="external-link" href="https://blog.csdn.net/ababab12345/article/details/102931841" target="_blank">shm &amp; mmap</a></p>
</blockquote></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded">shm_open
mmap
munmap
shm_unlink
ftruncate
</code><button class="copy-code-button">复制</button></pre></div><div><p><strong>套接字</strong></p></div><div><blockquote>
<p>套接字是一种进程间通信的形式，如同管道，fifo，信号量，共享存储等。套接字可以在不同通信范围（domain）内的进程之间通信，而套接字就是一个传输中介。</p>
</blockquote></div><div><p></p><div src="lib/media/socket结构.png" class="internal-embed media-embed image-embed is-loaded"><img src="lib/media/socket结构.png"></div><p></p></div><div><p>创建于销毁</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token comment">//domain确定通信范围(AF_INET,AF_INET6,AF_UNIX,AF_UNSPEC)，间接影响了地址格式</span>
<span class="token comment">//type确定套接字类型(SOCK_STREAM,SOCK_DGRAM,SOCK_RAW,SOCK_SEQPACKET)</span>
<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=描述符</span>

<span class="token comment">//how关闭套接字：SHUT_RD(关闭读取),SHUT_WR(关闭写入),SHUT_RDWR(关闭读写)</span>
<span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">,</span> <span class="token keyword">int</span> how<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p>设置套接字选项</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token comment">//option代表要设置套接字的功能选项，level代表选项所修改的协议。</span>
<span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> option<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">getsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> option<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>


</code><button class="copy-code-button">复制</button></pre></div><div><p>地址格式</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token comment">//地址格式：(地址格式，在不同的通信域中是不一样的。但为了使用同一套接口，不同地址可以转换成统一的地址:sockaddr)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;netinet/in.h&gt;</span></span>
	AF_INET域<span class="token operator">:</span>	
		sockaddr_in
		<span class="token punctuation">{</span>
							sin_family<span class="token punctuation">;</span>	<span class="token comment">//地址族</span>
							sin_port<span class="token punctuation">;</span>	<span class="token comment">//端口</span>
			<span class="token keyword">struct</span> <span class="token class-name">in_addr</span>	sin_addr<span class="token punctuation">;</span>	<span class="token comment">//ipv4地址</span>
		<span class="token punctuation">}</span>

		in_addr
		<span class="token punctuation">{</span>
			s_addr<span class="token punctuation">;</span>						<span class="token comment">//ipv4地址</span>
		<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/socket.h&gt;</span></span>
客户端：
	
		<span class="token comment">//创建socket</span>
		<span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span>	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span>addr<span class="token punctuation">,</span>	<span class="token class-name">socklen_t</span> len<span class="token punctuation">)</span><span class="token comment">//cg=0</span>

服务器：
		<span class="token comment">//socket绑定网卡</span>
		<span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> len<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
		<span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span>	<span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
		<span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span>	<span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span>addr<span class="token punctuation">,</span>	<span class="token class-name">socklen_t</span><span class="token operator">*</span> len<span class="token punctuation">)</span><span class="token comment">//cg=clientfd</span>

共用：
		<span class="token comment">//关闭socket</span>
		<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span><span class="token keyword">int</span> type<span class="token punctuation">,</span><span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token comment">//cg=socketfd</span>
		<span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span><span class="token keyword">int</span> how<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
		<span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
		<span class="token comment">//数据传输</span>
		<span class="token class-name">ssize_t</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span>buf<span class="token punctuation">,</span>	<span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span>	<span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">ssize_t</span> <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token comment">//设置套接字选项</span>
		<span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> option<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> val<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> len<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="线程" class="heading" id="线程"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>线程</h4><div class="heading-children"><div><p><strong>创建与销毁</strong></p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span></span>
    <span class="token keyword">int</span> <span class="token function">pthread_equal</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> t1<span class="token punctuation">,</span> <span class="token class-name">pthread_t</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不等0，相等=0</span>
    <span class="token class-name">pthread_t</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//线程id</span>
    <span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>tid<span class="token punctuation">,</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token operator">/</span>线程属性<span class="token operator">/</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">/</span>调用函数<span class="token operator">/</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>arg<span class="token operator">/</span>函数参数<span class="token operator">/</span><span class="token punctuation">)</span><span class="token comment">//cg=0</span>
    <span class="token comment">//线程退出的三种方式1.正常退出 2.被其他线程取消pthread_cancel，pthread_exit(PTHREAD_CANCELED) 3.调用pthread_exit</span>
    <span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span>\<span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程退出</span>
    <span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0//只是提出取消请求，具体是否取消可以在线程中设置</span>
    <span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> t<span class="token punctuation">,</span> <span class="token keyword">void</span>\<span class="token operator">*</span>\<span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="线程同步" class="heading" id="线程同步"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>线程同步</h4><div class="heading-children"><div><ul>
<li data-line="0">互斥量(pthread_mutex_t)</li>
</ul></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token comment">//初始化方法有两种1.pthread_mutex_t = PTHREAD_MUTEX_INITIALIZER; 2.使用下面的init方法。</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_mutexattr_t</span><span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> \<span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token comment">//互斥量加锁和解锁方法</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div><div><ul>
<li data-line="0">读写锁(pthread_rwlock_t)</li>
</ul></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token comment">//初始化方法</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_rwlockattr_t</span><span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//读写锁，两种加锁方式和一种解锁方式//cg=0</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span><span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span><span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span><span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">复制</button></pre></div><div><ul>
<li data-line="0">条件变量(pthread_cond_t)</li>
</ul></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token comment">//初始化方法有两种1.pthread_cond_t = PTHREAD_COND_INITIALIZER 2.使用下面的方法</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">,</span> <span class="token class-name">pthread_condattr_t</span><span class="token operator">*</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token comment">//等待条件发生</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span>cond<span class="token punctuation">,</span> <span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_timewait</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span>cond<span class="token punctuation">,</span>pthread_mutex<span class="token operator">*</span>mutex<span class="token punctuation">,</span><span class="token keyword">const</span> timespec<span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//cg=0</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="问题" class="heading" id="问题"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>问题</h3><div class="heading-children"><div class="heading-wrapper"><h4 data-heading="如何设计一个操作系统" class="heading" id="如何设计一个操作系统"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>如何设计一个操作系统</h4><div class="heading-children"><div><p>从用户的角度来看，<strong>操作系统的核心是由抽象概念和其上的基本操作所构成的</strong>，而基本操作则可通过系统调用加以利用</p></div><div><ol>
<li data-line="0">定义抽象概念（--进程抽象【cpu】、虚拟地址空间抽象【内存】、文件和目录抽象【硬盘】、IO抽象【键盘鼠标。。。】、）</li>
<li data-line="1">提供基本操作（向上，对开发人员）</li>
<li data-line="2">确保隔离</li>
<li data-line="3">管理硬件（对下，屏蔽硬件差异）</li>
</ol></div><div><p>进程有关的信息存放在：地址空间中、内核的进程表</p></div><div><p>地址空间：指令，数据，堆（储物间），栈（垃圾桶），外部数据源（文件，socket）</p></div></div></div><div class="heading-wrapper"><h4 data-heading="[C++服务器设计（一）：基于I/O复用的Reactor模式](https://www.cnblogs.com/moyangvip/p/5360837.html)" class="heading" id="[C++服务器设计（一）：基于I/O复用的Reactor模式](https://www.cnblogs.com/moyangvip/p/5360837.html)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.cnblogs.com/moyangvip/p/5360837.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/moyangvip/p/5360837.html" target="_blank">C++服务器设计（一）：基于I/O复用的Reactor模式</a></h4><div class="heading-children"><div><p>•阻塞式IO       阻塞于read（）<br>
•非阻塞IO       立即返回错误码（进程对多个套接字轮寻）<br>
•上两种+多线程 线程切换开销大<br>
•IO复用        调用epoll<br>
•异步IO        （内核将就绪的描述符，准备好并通知进程来取用。显然这样就解放了进程，将复杂任务交给内核来完成）<br>
•reactor模式   基于事件触发机制。将需要判断的描述符注册入reactor中，然后由reactor调用事件关联处理函数。</p></div><div><p>reactor：<br>
​描述符fd --事件<br>
​事件分用器 --epoll/poll/select<br>
​事件处理器 --将处理器中的回调函数声明为虚函数，便于具体的处理器继承和实现<br>
​reactor管理器 --包含事件分用器</p></div></div></div><div class="heading-wrapper"><h4 data-heading="虚拟地址空间vs虚拟内存" class="heading" id="虚拟地址空间vs虚拟内存"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>虚拟地址空间vs虚拟内存</h4><div class="heading-children"><div><ol>
<li data-line="0">虚拟内存=硬盘上的一块空间，当作内存看待。通过缺页中断来调入内存，通过页面替换算法调出内存</li>
<li data-line="1">虚拟地址空间 = 32位系统上，每一个进程有4GB的虚拟地址空间（虚拟的可用的空间）。当cpu寄存器CR0的31位分页标志位置为1时，cpu启用MMU机构（地址转换机构），读入虚拟地址，然后根据该进程在<strong>内核</strong>中对应的页目录和页表，将该进程的虚拟地址转换为实际的物理地址。<br>
{<br>
★ 每一个程序自以为自己真有4GB的空间。<br>
★ 每一个进程都有在内核区会有一个页表和页目录<br>
}</li>
<li data-line="6">可重定向文件（relocatable）：编译器编译而成的.o文件，可以重新定向组合成可执行文件也称之为目标文件</li>
<li data-line="7">可执行文件（executable）：操作系统能够直接运行的文件</li>
<li data-line="8">共享库（shared object）：在程序运行过程中被动态链接的文件，可以减小可执行文件的大小</li>
<li data-line="9">其中可执行文件和共享库文件都是由目标文件（.o文件）构成的，因此他们的文件格式和目标文件的格式是一样的，在linux上目标文件的格式称之为（elf）文件格式</li>
</ol></div></div></div><div class="heading-wrapper"><h4 data-heading="水平触发vs边缘触发" class="heading" id="水平触发vs边缘触发"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>水平触发vs边缘触发</h4><div class="heading-children"><div><blockquote>
<p>参考:</p>
<p>[epoll水平触发和边缘触发]<a rel="noopener" class="external-link" href="https://www.jianshu.com/p/7eaa0224d797" target="_blank">https://www.jianshu.com/p/7eaa0224d797</a></p>
</blockquote></div><div><ol>
<li data-line="0">
<p>读缓冲区刚开始是空的</p>
</li>
<li data-line="2">
<p>读缓冲区写入2KB数据</p>
</li>
<li data-line="4">
<p>水平触发（LT）和边缘触发模式（ET）此时都会发出可读信号</p>
</li>
<li data-line="6">
<p>收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据</p>
</li>
<li data-line="8">
<p>水平触发会再次进行通知，而边缘触发不会再进行通知，所以边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了，因为这一点，边缘触发需要设置文件句柄为非阻塞</p>
<pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token comment">//水平触发</span>
ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//边缘触发</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> EAGAIN<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre>
</li>
</ol></div><div><p>区别:水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次.</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="Reference" class="heading" id="Reference"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Reference</h2><div class="heading-children"><div><p><a data-tooltip-position="top" aria-label="https://blog.csdn.net/weixin_40204595/article/details/81109644" rel="noopener" class="external-link" href="https://blog.csdn.net/weixin_40204595/article/details/81109644" target="_blank">宏定义中的#，##的含义</a><br>
<a data-tooltip-position="top" aria-label="https://www.cnblogs.com/vanishfan/archive/2013/01/15/2861211.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/vanishfan/archive/2013/01/15/2861211.html" target="_blank">linux动态库链接规则</a></p></div><div class="mod-footer"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="_posts\os.html#os"><div class="tree-item-contents heading-link" heading-name="os"><span class="tree-item-title">os</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="_posts\os.html#内存管理"><div class="tree-item-contents heading-link" heading-name="内存管理"><span class="tree-item-title">内存管理</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#链接策略"><div class="tree-item-contents heading-link" heading-name="链接策略"><span class="tree-item-title">链接策略</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#装入策略（装入器loader）"><div class="tree-item-contents heading-link" heading-name="装入策略（装入器loader）"><span class="tree-item-title">装入策略（装入器loader）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#内存分配策略（内存管理器mm_manager）"><div class="tree-item-contents heading-link" heading-name="内存分配策略（内存管理器mm_manager）"><span class="tree-item-title">内存分配策略（内存管理器mm_manager）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="_posts\os.html#unix系统标准&amp;unix实现"><div class="tree-item-contents heading-link" heading-name="unix系统标准&amp;unix实现"><span class="tree-item-title">unix系统标准&amp;unix实现</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="_posts\os.html#磁盘到文件系统"><div class="tree-item-contents heading-link" heading-name="磁盘到文件系统"><span class="tree-item-title">磁盘到文件系统</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="_posts\os.html#系统调用"><div class="tree-item-contents heading-link" heading-name="系统调用"><span class="tree-item-title">系统调用</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#文件I/O"><div class="tree-item-contents heading-link" heading-name="文件I/O"><span class="tree-item-title">文件I/O</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#进程"><div class="tree-item-contents heading-link" heading-name="进程"><span class="tree-item-title">进程</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#进程间通信（IPC）"><div class="tree-item-contents heading-link" heading-name="进程间通信（IPC）"><span class="tree-item-title">进程间通信（IPC）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#线程"><div class="tree-item-contents heading-link" heading-name="线程"><span class="tree-item-title">线程</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#线程同步"><div class="tree-item-contents heading-link" heading-name="线程同步"><span class="tree-item-title">线程同步</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="_posts\os.html#问题"><div class="tree-item-contents heading-link" heading-name="问题"><span class="tree-item-title">问题</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#如何设计一个操作系统"><div class="tree-item-contents heading-link" heading-name="如何设计一个操作系统"><span class="tree-item-title">如何设计一个操作系统</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#[C++服务器设计（一）：基于I/O复用的Reactor模式](https://www.cnblogs.com/moyangvip/p/5360837.html)"><div class="tree-item-contents heading-link" heading-name="[C++服务器设计（一）：基于I/O复用的Reactor模式](https://www.cnblogs.com/moyangvip/p/5360837.html)"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.cnblogs.com/moyangvip/p/5360837.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/moyangvip/p/5360837.html" target="_blank">C++服务器设计（一）：基于I/O复用的Reactor模式</a></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#虚拟地址空间vs虚拟内存"><div class="tree-item-contents heading-link" heading-name="虚拟地址空间vs虚拟内存"><span class="tree-item-title">虚拟地址空间vs虚拟内存</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="_posts\os.html#水平触发vs边缘触发"><div class="tree-item-contents heading-link" heading-name="水平触发vs边缘触发"><span class="tree-item-title">水平触发vs边缘触发</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="_posts\os.html#Reference"><div class="tree-item-contents heading-link" heading-name="Reference"><span class="tree-item-title">Reference</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>